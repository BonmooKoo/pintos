# pintos

##1. Process Termnation
유저 프로세스 종료시, exit을 호출하는데, 
printf("%s: exit(%d)\n",full name , exit stat);출력

##2. Passing
현재 구현된 process_execute는 새로운 process에 인자를 전달하지 못함.
이 기능을 구현하기 위해서
"grep foo bar"을 file_name으로 받았으면,
grep 을 실행하고 foo 와 bar을 인자로하여서 전달하여야함.

##3. System Call
다음과 같은 시스템 콜들을 구현하여야함.
시스템 콜들은 lib/user/syscall.h를 통해서 유저 프로그램에게 보임
시스템 콜 번호들은 lib/syscall-nr.h에 정의됨.

##4. 쓰기 거부
대부분 OS들은 실행중인 파일에 대한 쓰기를 금지한다.
파일 쓰기 방지를 위해서 file_deny_write를 사용하고
파일 쓰기 방지 해제를 위해 file_allow_write를 사용하면 된다.
파일이 닫히면 자동으로 쓰기 방지가 해제된다.

##5. IPC
1. pipe() 시스템 콜을 구현한다.
SYS_PIPE
FD를 사용하여, 일반파일, 표준 IO 파이프를 처리할 수 있도록 syscall_handler에서 이를 구별해야한다.
각 FD의 타입을 저장할 방법을 찾아야한다.
FD 타입을 저장하는 방법으로 FD table이나 struct file을 수정할 수 있다.

```
int pipe (int* fds)
```
커널 공간에 버퍼를 할당한다
두개의 FD를 생성하여
fds[0] 읽기용 파이프
fds[1] 쓰기용 파이프
파이프 버퍼는 링 버퍼 형태로 구현한다
	1) 읽기 쓰기를 통해 파이프 FD에서 데이터를 읽고 쓸 수 있어야한다.
	2) 모든 리소스 할당이 성공하면 0을 반환하고 실패하면 -1을 반환한다.

2. exec에서 FDT 복사 및 파이프 FD 리디렉션
쉘에서 pipe를 사용하면 두개의 시스템 호출 dup()와 exec이 필요하다.
하지만 pintos에서는 fork 시스템 call이 없기 떄문에 exec이 fork와 exec의 역할을 동시에 수행한다.
즉, exec이 실행될때 부모의 FDT를 자식에게 복사하고, 파이프 리디렉션을 수행한다.
```
pid_t exec(const char* cmd_line)
```
부모의 FDT를 자식 프로세스에 복사한다.
(파이프 리디렉션과정)
만약 부모가 pipe를 호출했다면 자식의 FD 0 (기존의 STDIN)을 fds[0]으로 변경한다
이후 자식의 기존 파이프 FD(fds[1])를 정리한다.
한번의 파이프 호출만 처리하고 여러개의 파이프는 고려하지 않는다.

write / read / close 도 처리해야한다.
기존 파일 뿐 아니라, 파이프 FD 도 처리할 수 있도록 수정해야한다.
FD의 타입을 확인하고 적절한 동작을 수행해야한다.

void close
파이프 FD를 닫는다
프로세스가 종료되거나 close(fd)를 호출하면, 관련된 파이프 FD를 닫는다.
모든 파이프 FD가 닫혔다면, 커널에서 할당된 파이프 버퍼를 해제한다.

int write
파일이 아니라 파이프테 데이터를 쓰는 경우를 처리한다.
만약 fd가 파이프의 읽기(fds[0]) 끝이라면 -1을 반홚난다.
만약 모든 읽기 (fds[0])이 닫혔다면 , 쓰기 요청을 거부하고 -1을 반환한다.
버퍼가 가득찼으면, 테이터가 소비될 때 까지 wait 를 해야한다.
쓰기 요청이 성공하면 size를 반환하고 실패하면 -1을 반환한다.

int read
파일이 아니라 파이프에서 데이터를 읽는 경우를 처리한다.
만약 fd가 파이프의 쓰기(fds[1])끝이라면 -1을 반환한다.
읽기 작업은 두단계이다.
1) 버퍼가 비어있으면 wait()한다.
2) 데이터가 존재하면 가능한만큼 읽고 즉시 반환한다.
읽기 요청이 성공하면 실제 읽은 바이트 수를 반환하고, 실패하면 -1을 반환한다.


